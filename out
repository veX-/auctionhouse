diff --git a/src/app/Main.java b/src/app/Main.java
index fdeca17..0e75ee6 100644
--- a/src/app/Main.java
+++ b/src/app/Main.java
@@ -10,10 +10,10 @@ public class Main {
 	private Mediator med;
 	protected Logger l;
 
-	public Main(String configFile, String scenarioFile, String ip, int port) {
-		med = new Mediator(configFile);
+	public Main(String ip, int port, String configFile) {
+		med = new Mediator(ip, port, configFile);
 
-		med.getNetMed().startServer(ip, port, scenarioFile);
+		med.getNetMed().startServer(ip, port);
 
 		EventQueue.invokeLater(new Runnable() {
 
@@ -28,15 +28,29 @@ public class Main {
 	}
 
 	public static void main(String[] args) {
-		if (args.length < 4) {
-			System.err.println("Usage: java Main <filename> <ip> <port> <scenario_file>");
+		
+		if (args.length < 2) {
+			System.err.println("Usage: java Main <ip> <port> [<filename>]");
 			System.exit(1);
 		}
-		final String configFile = args[0];
-		final String ip = args[1];
-		final int port = Integer.parseInt(args[2]);
-		final String scenarioFile = args[3];
-
-		new Main(configFile, scenarioFile, ip, port);
+		
+		if (args.length == 2) {
+			
+			final String ip = args[0];
+			final int port = Integer.parseInt(args[1]);
+			
+			System.out.println("[Auction House]: Running in Login Server Mode");
+			
+			Mediator med = new Mediator(ip, port, null);
+			med.getNetMed().startLoginServer(ip, port);
+			
+		} else {
+			
+			final String ip = args[0];
+			final int port = Integer.parseInt(args[1]);
+			final String configFile = args[2];
+	
+			new Main(ip, port, configFile);
+		}
 	}
 }
diff --git a/src/app/Mediator.java b/src/app/Mediator.java
index f63ce4c..5b8e09e 100644
--- a/src/app/Mediator.java
+++ b/src/app/Mediator.java
@@ -5,7 +5,6 @@ import gui.GUIMediatorImpl;
 
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -35,10 +34,14 @@ public class Mediator implements WSClientMediator {
 	private NetworkMediator netMed;
 	private GUIMediator guiMed;
 	private Logger logger = null;
+	private String serverIp;
+	private int serverPort;
 	
 	private HashMap<String, User> relevantUsers;
 
-	public Mediator(String configFile) {
+	public Mediator(String ip, int port, String configFile) {
+		this.serverIp = ip;
+		this.serverPort = port;
 		this.configFile = configFile;
 		mgr = new StateManager(this);
 		netMed = new NetworkMockup(this);
@@ -162,26 +165,31 @@ public class Mediator implements WSClientMediator {
 	}
 
 	public boolean logIn(String username, String password, String type) {
-		// TODO authenticate against database
-		if (true) {
-			String logFile = String.format(LOG_FILE_FORMAT, username);
-			System.setProperty("logfile.name", logFile);
-			logger = Logger.getLogger(Mediator.class.getName());
-			logger.info(String.format("Welcome to Auction House, %s!", username));
-
-			if (type.equalsIgnoreCase(User.buyerType))
-				mgr.setBuyerState();
-			else
-				mgr.setSellerState();
-			mgr.login(username);
-
-			tempReadConfig(username, type);
-		}
+		
+		String logFile = String.format(LOG_FILE_FORMAT, username);
+		System.setProperty("logfile.name", logFile);
+		logger = Logger.getLogger(Mediator.class.getName());
+		logger.info(String.format("Welcome to Auction House, %s!", username));
+
+		if (type.equalsIgnoreCase(User.buyerType))
+			mgr.setBuyerState();
+		else
+			mgr.setSellerState();
+		mgr.login(username);
+
+		Vector<String> products = tempReadConfig(username, type);
+		
+		if (!netMed.validateUsername(username, password, type,
+									 serverIp, serverPort, products))
+			return false;
+		
+		loadInitialProdList(username, type, products);
+		
 		return true;
 	}
 
-	private void tempReadConfig(String user, String type) {
-		List<String> products = null;
+	private Vector<String> tempReadConfig(String user, String type) {
+		Vector<String> products = null;
 		File f = new File(configFile);
 		Scanner s = null;
 
@@ -192,12 +200,11 @@ public class Mediator implements WSClientMediator {
 			s.nextLine(); //type
 
 			/* Read the list of products. */
-			products = new ArrayList<String>();
+			products = new Vector<String>();
 			while (s.hasNextLine()) {
 				String line = s.nextLine();
 				products.add(line);
 			}
-			this.loadInitialProdList(user, type, products);
 
 		} catch (FileNotFoundException e) {
 			e.printStackTrace();
@@ -205,6 +212,8 @@ public class Mediator implements WSClientMediator {
 			if (s != null)
 				s.close();
 		}
+
+		return products;
 	}
 
 	public boolean logOut() {
diff --git a/src/app/model/User.java b/src/app/model/User.java
index 96757c2..2a0255d 100644
--- a/src/app/model/User.java
+++ b/src/app/model/User.java
@@ -30,7 +30,10 @@ abstract public class User {
 		this.port = port;
 		this.items = items;
 		
-		this.bids = new Vector<Integer>(items.size());
+		if (items == null)
+			this.bids = null;
+		else
+			this.bids = new Vector<Integer>(items.size());
 	}
 
 	public String getName() {
diff --git a/src/app/states/RequestTypes.java b/src/app/states/RequestTypes.java
index 570a0e2..36221d6 100644
--- a/src/app/states/RequestTypes.java
+++ b/src/app/states/RequestTypes.java
@@ -15,8 +15,14 @@ public class RequestTypes {
 	public static final int REQUEST_ACCEPT_OFFER = 3;
 	public static final int REQUEST_REFUSE_OFFER = 4;
 	public static final int REQUEST_DROP_AUCTION = 5;
-	
+
 	/* internally generated requests */
 	public static final int REQUEST_INITIAL_TRANSFER = 6;
 	public static final int REQUEST_TRANSFER = 7;
+
+	/* WS related actions */
+	public static final int REQUEST_LOGIN = 8;
+	public static final int REQUEST_LOGOUT = 9;
+	public static final int SYSTEM_LOGIN_FAILURE = 10;
+	public static final int SYSTEM_NEW_LOGIN_EVENT = 11;
 }
diff --git a/src/network/NetworkMediator.java b/src/network/NetworkMediator.java
index 0b6d0c5..24aab4f 100644
--- a/src/network/NetworkMediator.java
+++ b/src/network/NetworkMediator.java
@@ -19,7 +19,17 @@ public interface NetworkMediator {
 	public void sendDropAnnouncement(String[] users, String productName,
 			String userId);
 
-	public void startServer(String ip, int port, String scenarioFile);
+	public void startLoginServer(String ip, int port);
+	public void startServer(String ip, int port);
+	
+	public boolean validateUsername(String username, String password, String type,
+									String ip, int port, Vector<String> products);
+	
+	public void setLoginFailed();
+	
+	public void setLoginSuccess();
+	
+	public boolean sendLoginNotification(int action, String ip, int port, User user);
 	
 	public boolean sendNotifications(int action, String userName, String product,
 			int price, Vector<User> destinations);
diff --git a/src/network/NetworkMockup.java b/src/network/NetworkMockup.java
index a8bccab..36f4fea 100644
--- a/src/network/NetworkMockup.java
+++ b/src/network/NetworkMockup.java
@@ -17,8 +17,17 @@ import app.model.User;
 import app.states.RequestTypes;
 
 public class NetworkMockup implements NetworkMediator {
-
+	
+	public static final int LOGIN_PENDING = 0;
+	public static final int LOGIN_SUCCESS = 1;
+	public static final int LOGIN_FAILED = 2;
+	
 	public static boolean running = true;
+	private static int loginStatus = LOGIN_PENDING;
+	
+	public static final String LOGIN_SERVER_IP = "127.0.0.1";
+	public static final int LOGIN_SERVER_PORT = 11011;
+
 
 	private final int MIN_FILE_SIZE = 256;
 	private final int MAX_FILE_SIZE = 2048;
@@ -151,6 +160,53 @@ public class NetworkMockup implements NetworkMediator {
 		return true;
 	}
 
+	public void setLoginFailed() {
+		loginStatus = LOGIN_FAILED;
+	}
+	
+	public void setLoginSuccess() {
+		loginStatus = LOGIN_SUCCESS;
+	}
+	
+	/**
+	 * 
+	 */
+	public boolean validateUsername(String username, String password, String type,
+									String ip, int port, Vector<String> products) {
+		
+		NetworkNotification nn = new NetworkNotification(
+				RequestTypes.REQUEST_LOGIN,
+				username,
+				password,
+				type,
+				ip,
+				port,
+				products);
+		
+		if (!doNetworkSend(LOGIN_SERVER_IP, LOGIN_SERVER_PORT, nn)) {
+			System.out.println("[NETWORK]: Failed to send login request");
+			return false;
+		}
+		
+		System.out.println("[NETWORK]: Waiting for login confirmation...");
+		
+		/* wait for a confirmation */
+		while (loginStatus == LOGIN_PENDING) {
+			try {
+				Thread.sleep(100);
+			} catch (InterruptedException e) {
+				e.printStackTrace();
+			}
+		}
+
+		if (loginStatus == LOGIN_FAILED)
+			return false;
+
+		System.out.println("[NETWORK]: Login successful!");
+
+		return true;
+	}
+	
 	/**
 	 * Handles a generic PopUp menu request
 	 * 
@@ -180,6 +236,14 @@ public class NetworkMockup implements NetworkMediator {
 	}
 	
 	/**
+	 * Submits a login notification (only called in Login Server mode)
+	 */
+	public boolean sendLoginNotification(int action, String ip, int port, User user) {
+		
+		return false;
+	}
+	
+	/**
 	 * Sends a serialized NetworkNotification class to the specified destination
 	 * 
 	 * @param ip destination IP
@@ -259,7 +323,11 @@ public class NetworkMockup implements NetworkMediator {
 		return true;
 	}
 
-	public void startServer(String ip, int port, String scenarioFile) {
-		new NetworkServer(ip, port, med, scenarioFile).start();
+	public void startLoginServer(String ip, int port) {
+		new NetworkServer(ip, port, med, true).start();
+	}
+	
+	public void startServer(String ip, int port) {
+		new NetworkServer(ip, port, med, false).start();
 	}
 }
diff --git a/src/network/NetworkNotification.java b/src/network/NetworkNotification.java
index 97c7019..485c86b 100644
--- a/src/network/NetworkNotification.java
+++ b/src/network/NetworkNotification.java
@@ -1,5 +1,7 @@
 package network;
 
+import java.util.Vector;
+
 public class NetworkNotification implements java.io.Serializable {
 
 	private static final long serialVersionUID = -2406982845299543963L;
@@ -7,8 +9,13 @@ public class NetworkNotification implements java.io.Serializable {
 	private int action;
 	private String name;
 	private String product;
+	private String type;
 	private int price;
 	private byte[] productChunk;
+	
+	private String ip;
+	private int port;
+	private Vector<String> products;
 
 	public NetworkNotification(int action, String name, String product,
 			int price) {
@@ -18,6 +25,17 @@ public class NetworkNotification implements java.io.Serializable {
 		this.price = price;
 	}
 
+	public NetworkNotification(int action, String username, String password,
+			String type, String ip, int port, Vector<String> products) {
+		this.action = action;
+		this.name = username;
+		this.product = password;
+		this.type = type;
+		this.products = products;
+		this.ip = ip;
+		this.port = port;
+	}
+
 	public NetworkNotification(int action, String name, String product,
 			int price, byte[] chunk) {
 
@@ -48,6 +66,22 @@ public class NetworkNotification implements java.io.Serializable {
 		return price;
 	}
 	
+	public String getType() {
+		return type;
+	}
+	
+	public String getIp() {
+		return ip;
+	}
+	
+	public int getPort() {
+		return port;
+	}
+	
+	public Vector<String> getProducts() {
+		return products;
+	}
+	
 	public byte[] getChunk() {
 		return productChunk;
 	}
diff --git a/src/network/NetworkServer.java b/src/network/NetworkServer.java
index 7a5216a..6e3cb17 100644
--- a/src/network/NetworkServer.java
+++ b/src/network/NetworkServer.java
@@ -10,18 +10,27 @@ import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
+import java.util.HashMap;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Scanner;
 import java.util.Vector;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
 import app.Mediator;
+import app.model.Seller;
+import app.model.User;
+import app.states.RequestTypes;
 
 public class NetworkServer extends Thread {
 
 	private static final int LISTENER_THREADS = 2;
 	private static final int BUFFER_SIZE = 8192;
+	
+	private HashMap<String, User> systemUsers;
+	
+	private final boolean loginServerMode;
 
 	private static ExecutorService pool = Executors
 			.newFixedThreadPool(LISTENER_THREADS);
@@ -30,16 +39,108 @@ public class NetworkServer extends Thread {
 
 	private String ip;
 	private int port;
-	private String scenarioFile;
 
-	public NetworkServer(String ip, int port, Mediator med, String scenarioFile) {
+	/* 
+	 * set @mode to true if you want to enable Login Server Mode,
+	 * making the application act as a Central User Login entity
+	 */
+	public NetworkServer(String ip, int port, Mediator med, boolean mode) {
+		this.loginServerMode = mode;
 		this.ip = ip;
 		this.port = port;
-		this.scenarioFile = scenarioFile;
 
 		this.med = med;
+		systemUsers = new HashMap<String, User>();
 	}
 
+	public boolean handleLoginServerRequest(NetworkNotification nn) {
+		
+		Vector<User> dests = new Vector<User>();
+		
+		String userName = nn.getName();
+		
+		dests.add(new Seller("", nn.getIp(), nn.getPort(), null));
+		
+		System.out.println("[Login Server]: Processing login request...");
+		
+		switch (nn.getAction()) {
+		case RequestTypes.REQUEST_LOGIN:
+
+			/* already logged in from another place! */
+			if (systemUsers.get(userName) != null) {
+				
+				med.getNetMed().sendNotifications(RequestTypes.SYSTEM_LOGIN_FAILURE,
+						"", "", 0, dests);
+
+				return false;
+			}
+			
+			System.out.println("[Login Server]: Sending ACK back to " + nn.getIp() + " " + nn.getPort());
+			
+			med.getNetMed().sendLoginNotification(RequestTypes.REQUEST_LOGIN,
+					nn.getIp(), nn.getPort(), null);
+
+			Vector<String> userProducts = nn.getProducts();
+			
+			for (Map.Entry<String, User> e : systemUsers.entrySet()) {
+				
+				User user = e.getValue();
+				Vector<String> commonProducts = new Vector<String>();
+				
+				for (String s : user.getItems()) {
+					if (userProducts.contains(s)) {
+						commonProducts.add(s);
+					}
+				}
+				
+				if (commonProducts.size() > 0) {
+					
+					med.getNetMed().sendLoginNotification(RequestTypes.SYSTEM_NEW_LOGIN_EVENT,
+							nn.getIp(), nn.getPort(),
+							new Seller(e.getKey(), user.getIp(), user.getPort(), commonProducts));
+					
+					med.getNetMed().sendLoginNotification(RequestTypes.SYSTEM_NEW_LOGIN_EVENT,
+							user.getIp(), user.getPort(),
+							new Seller(userName, nn.getIp(), nn.getPort(), commonProducts));
+				}
+			}
+
+			systemUsers.put(userName,
+							new Seller(userName, nn.getIp(), nn.getPort(), userProducts));
+
+			break;
+			
+		case RequestTypes.REQUEST_LOGOUT:
+			
+			userProducts = systemUsers.get(userName).getItems();
+		
+			for (Map.Entry<String, User> e : systemUsers.entrySet()) {
+			
+				User user = e.getValue();
+				
+				for (String s : user.getItems()) {
+					if (userProducts.contains(s)) {
+						
+						med.getNetMed().sendLoginNotification(RequestTypes.REQUEST_LOGOUT,
+								user.getIp(), user.getPort(),
+								new Seller(userName, nn.getIp(), nn.getPort(), null));
+						
+						break;
+					}
+				}
+			}
+			
+			systemUsers.remove(userName);
+			
+			break;
+		default:
+			System.out.println("[LOGIN SERVER]: Invalid request type: " + nn.getAction());
+			return false;
+		}
+		
+		return true;
+	}
+	
 	public void accept(SelectionKey key) throws IOException {
 
 		ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key
@@ -84,12 +185,36 @@ public class NetworkServer extends Thread {
 
 						NetworkNotification nn = unmarshal(buf);
 
-						System.out.println("[NETWORK]: Received notification: "
-								+ nn);
+						System.out.println("[NETWORK]: Received notification: " + nn);
+						
+						if (loginServerMode) {
+							handleLoginServerRequest(nn);
+							
+							return;
+						}
+
+						if (nn.getAction() == RequestTypes.SYSTEM_LOGIN_FAILURE) {
+							med.getNetMed().setLoginFailed();
+							return;
+						}
+						
+						if (nn.getAction() == RequestTypes.SYSTEM_NEW_LOGIN_EVENT) {
+							
+							med.handleLoginEvent(nn.getIp(), nn.getPort(), nn.getName(),
+									nn.getProducts());
+							
+							return;
+						}
+						
+						if (nn.getAction() == RequestTypes.REQUEST_LOGIN) {
+							med.getNetMed().setLoginSuccess();
+							
+							return;
+						}
 
 						med.updateGui(nn.getAction(), nn.getName(),
 								nn.getProduct(), nn.getPrice());
-
+						
 					} catch (IOException e) {
 						System.out.println("[NETWORK]: Connection closed: "
 								+ e.getMessage());
@@ -173,8 +298,6 @@ public class NetworkServer extends Thread {
 		ServerSocketChannel serverSocketChannel = null;
 		Selector selector = null;
 
-		//loadSystemOverview(scenarioFile);
-
 		try {
 			selector = Selector.open();
 
